## LOCK 接口 ##

### 加锁 ###

- lock() 类似synchronized关键字，如果锁不可用，出于线程调度的目的，线程将休眠到获得锁 
- lockInterruptibly() 于lock()唯一区别是锁不可用则立即中断所以抛出中断异常
- tryLock() 尝试获取锁，可以在参数中增加等待时间，期间线程不会中断
- unlock() 释放锁

### Condition接口 ###

- await() 执行await方法后，当前线程立即释放锁并进入唤醒等待区等待其他线程将其唤醒或中断，可以
在参数中加入等待唤醒的时间。
- awaitUninterruptibly() 等待超时不会被中断会一直等待。
- awaitUntil(),awaitUntilNanos() 设置等待时间或截止日期。
- signal() 唤醒等待线程。
- signalAll() 唤醒所有线程。

### ReadWriteLock ### 

- 概念 读写锁，是一对相关的锁——读锁和写锁，读锁用于只读操作，写锁用于写入操作。
读锁可以由多个线程同时保持，而写锁是独占的，只能由一个线程获取。


## LOCK接口实现 ##


### ReentrantLock ###

- 概念 ReentrantLock类，实现了Lock接口，是一种可重入的独占锁，它具有与使用 synchronized 相同的一些基本行为和语义，但功能更强大。
ReentrantLock内部通过内部类实现了AQS框架(AbstractQueuedSynchronizer)的API来实现独占锁的功能。

- 构造器，构造方法中通过指定 boolean类型参数 fair来指定锁是公平还是非公平策略。默认非公平。
一般情况下，使用公平策略的程序在多线程访问时，总体吞吐量（即速度很慢，常常极其慢）比较低，因为此时在线程调度上面的开销比较大。

    - 公平策略：在多个线程争用锁的情况下，公平策略倾向于将访问权授予等待时间最长的线程。也就是说，相当于有一个线程等待队列，先进入等待队列的线程后续会先获得锁，这样按照“先来后到”的原则，对于每一个等待线程都是公平的。
    - 非公平策略：在多个线程争用锁的情况下，能够最终获得锁的线程是随机的（由底层OS调度）。
    
### ReentrantReadWriteLock ###

- 概念 读写锁，它是ReadWriteLock接口的直接实现，该类在内部实现了具体独占锁特点的写锁，以及具有共享锁特点的读锁。
和ReentrantLock一样，ReentrantReadWriteLock类也是通过定义内部类实现AQS框架的API来实现独占/共享的功能。

- 支持锁重入和锁降级，但是写锁的重入和降级建立在获取写锁的前提下。多线程下可以获取多个读锁，但写锁只有一个线程拥有。
- 读写锁的condition只有写锁可以获取，读锁不需要condition


## LockSupport ##

- 概念 LockSupport类，是JUC包中的一个工具类，是用来创建锁和其他同步类的基本线程阻塞原语。
可以把这种锁看成是ReentrantLock的公平锁简单版本，且是不可重入的，就是说当一个线程获得锁后，其它等待线程以FIFO的调度方式等待获取锁。

- park() 阻塞当前线程
- unpark() 唤醒指定线程


